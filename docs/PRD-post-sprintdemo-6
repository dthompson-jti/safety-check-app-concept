Here are 5 PRDs, ordered from lowest risk/highest immediate impact to highest architectural complexity.

---

## PRD 1: Visual Physics & Context-Aware Simulation
**Priority:** High (Quick Wins) | **Risk:** Low

### 1. Overview
This initiative unifies the application's motion language by applying spring physics to global layout transitions, fixes the jarring layout shift during loading states, and ensures the "Simulate Scan" feature is context-aware for better demos.

### 2. Problem & Goals
*   **Problem:**
    *   Full-screen slides feel robotic due to linear tweening.
    *   Replacing Skeletons with Cards causes a visible "blink" or layout jump.
    *   The "Simulate Success" button in Scan View picks a random check, often confusing the user by completing an item outside their current view/unit (e.g., scanning a Sci-Fi check while in JDC).
*   **Goals:**
    *   Implement fluid spring physics for the main film-strip navigation.
    *   Create a seamless cross-fade between loading skeletons and real content.
    *   Ensure the "Simulate Scan" button always targets the top-most *pending* item in the currently active view.

### 3. Scope & Key Initiatives
*   **Global Physics:** Update `MainLayout` to use spring physics.
*   **Skeleton Crossfade:** Refactor `ScheduleListView` to strictly position skeletons to prevent layout shifts during data insertion.
*   **Smart Simulation:** Update `ScanView` logic to read the current `contextFilteredChecksAtom` instead of the raw global list.
*   **Out of Scope:** Changing animation physics for small micro-interactions (toggles, checkboxes) which should remain tweens.

### 4. UX/UI Specification & Wireframes
**Visual Design:**
*   **Main Layout:** Swipes should have "weight" and "momentum" (Spring damping ~30, stiffness ~300).
*   **Loading:** Content should fade in *over* the skeleton while the skeleton fades out, occupying the exact same pixel space.

### 5. Architecture & Implementation Plan
1.  **Animation:** Update `viewTransition` in `MainLayout.tsx` to use `type: "spring"`.
2.  **Skeleton Wrapper:** Wrap `CheckSkeleton` and the list in a CSS Grid where both occupy `grid-area: 1 / 1`. This allows them to overlap perfectly during the cross-fade transition handled by `AnimatePresence`.
3.  **Smart Scan Logic:**
    *   Inject `contextFilteredChecksAtom` into `ScanView`.
    *   Filter for the first item where `status !== 'complete'`.
    *   Use that ID for `handleDecode`.

### 6. File Manifest
*   `src/layouts/MainLayout.tsx` [MODIFIED]
*   `src/features/Schedule/ScheduleListView.tsx` [MODIFIED]
*   `src/features/Schedule/ScheduleLayouts.module.css` [MODIFIED]
*   `src/features/Workflow/ScanView.tsx` [MODIFIED]
*   `src/components/CheckSkeleton.tsx` [REFERENCE]

### 7. Unintended Consequences Check
*   **Spring Physics:** Ensure `overflow: hidden` is strictly set on `MainLayout.module.css`, otherwise spring "overshoot" might reveal whitespace or scrollbars.

### 8. Risks & Mitigations
*   **Risk:** Overlapping content during crossfade might cause double-height scrollbars momentarily.
*   **Mitigation:** Use `mode="popLayout"` in Framer Motion or explicit CSS Grid stacking to enforce dimensions.

### 9. Definition of Done
*   [ ] Swiping between Time and Route views feels "heavy" and fluid (Spring).
*   [ ] Loading skeletons transition to cards with zero layout shift.
*   [ ] Clicking "Simulate Success" in JDC A-Wing completes a check in JDC A-Wing.

---

## PRD 2: Performance Core (Centralized Heartbeat)
**Priority:** High (Performance) | **Risk:** Low

### 1. Overview
Refactor the countdown timer logic to use a single, centralized "Heartbeat" atom rather than having every list item run its own animation loop.

### 2. Problem & Goals
*   **Problem:** Currently, `useCountdown.ts` instantiates a `requestAnimationFrame` loop for *every* row. With 100 rows, this is 100 simultaneous loops, draining battery and CPU.
*   **Goals:** Reduce to exactly **one** `requestAnimationFrame` loop for the entire application.

### 3. Scope & Key Initiatives
*   **Heartbeat Atom:** Create a global `nowAtom` that updates once per second (or 100ms).
*   **Subscription:** Update `useCountdown` to read from this atom instead of setting its own state.
*   **Out of Scope:** changing the visual formatting of the time string.

### 4. UX/UI Specification
*   *No visual changes.* The countdowns will look identical but perform better.

### 5. Architecture & Implementation Plan
1.  **Create `src/data/timeAtoms.ts`:**
    *   Create `globalTickerAtom`.
    *   Create a hook `useGlobalTicker` that sets up the interval/RAF only when there is at least one subscriber.
2.  **Refactor `useCountdown`:**
    *   Remove `useState` and `useEffect` loops.
    *   Simply return `formatTime(due, useAtomValue(globalTickerAtom))`.

### 6. File Manifest
*   `src/data/timeAtoms.ts` [NEW]
*   `src/data/useCountdown.ts` [MODIFIED]
*   `src/features/Schedule/CheckCard.tsx` [REFERENCE]
*   `src/features/Schedule/CheckListItem.tsx` [REFERENCE]

### 7. Unintended Consequences Check
*   Check `AppShell.tsx` where `currentTimeAtom` is currently set. This might be redundant or can be merged.

### 8. Risks & Mitigations
*   **Risk:** If the global atom updates too frequently (e.g., every frame), it will trigger a re-render of *every* card 60 times a second.
*   **Mitigation:** Throttle the global ticker to 100ms or 1s depending on the finest granularity needed (we display seconds, so 100ms is safe).

### 9. Definition of Done
*   [ ] Only one active interval/RAF is visible in Chrome Performance Profiler when the schedule is open.
*   [ ] Timers still count down accurately.

---

## PRD 3: Offline Experience Overhaul
**Priority:** Medium | **Risk:** Medium

### 1. Overview
A complete redesign of the offline UI to provide a high-craft, confidence-inspiring experience that clearly communicates state without nagging toasts.

### 2. Problem & Goals
*   **Problem:** The current "Offline" banner is generic. Queued checks trigger a Toast, which feels ephemeral and "error-like". The status bar queue count is disconnected from the sync action.
*   **Goals:** Consolidate offline status, duration, and queue count into a single, actionable header. Remove redundant indicators.

### 3. Scope & Key Initiatives
*   **Offline Header:** Design a 2-line header (Status/Duration + Queue Count/Action).
*   **Toast Removal:** Suppress "Check Queued" toasts.
*   **Status Bar Cleanup:** Remove the "Queued" pill from the `StatusOverviewBar`.

### 4. UX/UI Specification & Wireframes

**New Offline Header (`OfflineBanner.tsx`):**
```text
+-------------------------------------------------------+
|  [CloudOff]  Offline for 12m                          |
|  5 checks queued for sync             [ Sync Now ]    |
+-------------------------------------------------------+
BG: var(--surface-bg-primary-solid) (Dark)
Text: var(--surface-fg-on-solid)
Button: Text link style, underlined
```

**Interaction:**
*   The "Sync Now" button triggers the sync simulation.
*   The header persists as long as the user is offline.

### 5. Architecture & Implementation Plan
1.  **Offline Duration:** Add `offlineTimestampAtom` to track when the connection was lost.
2.  **Update `OfflineBanner`:** Implement the 2-line layout. Calculate "Offline for Xm" based on the timestamp.
3.  **Update `StatusOverviewBar`:** Remove the logic that renders the `queued` pill.
4.  **Update `CheckFormView`:** Remove the `addToast` call when saving offline.

### 6. File Manifest
*   `src/features/Shell/OfflineBanner.tsx` [MODIFIED]
*   `src/features/Shell/OfflineBanner.module.css` [MODIFIED]
*   `src/features/Shell/StatusOverviewBar.tsx` [MODIFIED]
*   `src/features/Workflow/CheckFormView.tsx` [MODIFIED]
*   `src/data/atoms.ts` (Add `offlineTimestampAtom`) [MODIFIED]

### 7. Unintended Consequences Check
*   Ensure `FloatingHeader` layout calculations (the CSS variable) account for the potentially changing height of this banner if it shifts content.

### 8. Risks & Mitigations
*   **Risk:** Header taking up too much vertical space on small phones.
*   **Mitigation:** Ensure font sizes are `0.8rem` or smaller for secondary text. Use a compact 2-line layout.

### 9. Definition of Done
*   [ ] Offline Banner shows "Offline for Xm".
*   [ ] Saving a check offline increments the count in the banner immediately.
*   [ ] No toasts appear on offline save.
*   [ ] Status Overview Bar does not show "Queued".

---

## PRD 4: Sensory & Input Experience
**Priority:** Medium | **Risk:** Medium

### 1. Overview
Enhance the "tangibility" of the app with sound effects, a dedicated NFC footer, and improved keyboard ergonomics.

### 2. Problem & Goals
*   **Problem:** NFC mode hides the primary footer, leaving no indication of readiness. Keyboards cover the "Save" button on mobile. Lack of audio feedback makes the app feel "webby".
*   **Goals:** Add "Ready to Scan" footer for NFC. Ensure forms are keyboard-safe. Add subtle sound design.

### 3. Scope & Key Initiatives
*   **NFC Footer:** A specific footer state when `scanMode === 'nfc'`.
*   **Sound:** Integrate `use-sound` (or native Audio) for Success/Error/Click.
*   **Keyboard:** Implement `dvh` units or a ResizeObserver to handle virtual keyboard resizing on `CheckFormView`.

### 4. UX/UI Specification & Wireframes

**NFC Footer:**
```text
+-------------------------------------------------------+
|      ((o))  Ready to Scan                             |
+-------------------------------------------------------+
BG: var(--surface-bg-primary)
Icon: Pulsing animation (CSS keyframes)
Text: var(--surface-fg-secondary)
```

**Sound Map:**
*   **Success:** Subtle "Ding" (High pitch, short decay).
*   **Error:** Low pitch "Thud" or "Buzz".
*   **Queued:** "Paper slide" or "Click".

### 5. Architecture & Implementation Plan
1.  **Library:** Evaluate `use-sound` vs simple `new Audio()`. Simple Audio is likely sufficient and lighter.
2.  **Hook:** Enhance `useHaptics` to `useSensoryFeedback` which triggers both vibe and sound.
3.  **Footer:** Update `FloatingFooter.tsx` to render the NFC state instead of returning `null`.
4.  **Viewport:** Update `CheckFormView.module.css` to use `height: 100dvh` to strictly bind to the visible viewport.

### 6. File Manifest
*   `src/features/Shell/FloatingFooter.tsx` [MODIFIED]
*   `src/features/Shell/FloatingFooter.module.css` [MODIFIED]
*   `src/data/useHaptics.ts` -> `src/data/useSensory.ts` [RENAME/MODIFIED]
*   `src/features/Workflow/CheckFormView.module.css` [MODIFIED]
*   `public/sounds/*.mp3` [NEW]

### 7. Unintended Consequences Check
*   **Audio:** Browsers block auto-playing audio. Ensure audio is only triggered by user interaction events.

### 8. Risks & Mitigations
*   **Risk:** Audio being annoying.
*   **Mitigation:** Add a "Sound" toggle in Settings (Reuse the Haptics toggle pattern).

### 9. Definition of Done
*   [ ] NFC mode shows "Ready to Scan" footer.
*   [ ] Completing a check plays a sound.
*   [ ] Keyboard opening on mobile does not hide the Save button.

---

## PRD 5: Data Architecture & Persistence (Evaluation & Optimization)
**Priority:** Low (High Effort/Complexity) | **Risk:** High

### 1. Overview
Address the data derivation bottlenecks and implement session persistence to make the prototype feel "real" across reloads.

### 2. Problem & Goals
*   **Problem:** Reloading the page resets the view to "Time" and "Card" mode. Search filtering runs on every keystroke across the entire dataset.
*   **Goals:** Persist user preferences. Optimize filtering. Evaluate changing the state library (e.g., to Zustand or XState).

### 3. Scope & Key Initiatives
*   **Persistence:** Use `atomWithStorage` for `appConfigAtom` and `sessionAtom`.
*   **Draft State:** Cache form inputs in `localStorage` keyed by `checkId` so "Back" doesn't lose data.
*   **Optimization:** Debounce the search input atom.
*   **State Lib Evaluation:** (Internal Note) Jotai is working well for this atomic structure. Switching to Redux/Zustand would be a rewrite. The recommendation is to *stick with Jotai* but use its advanced features (Split atoms / atom families) if performance degrades further.

### 4. UX/UI Specification
*   *Behavioral changes only.* The app "remembers" where you were.

### 5. Architecture & Implementation Plan
1.  **Persistence:**
    *   Replace `atom<AppConfig>` with `atomWithStorage<AppConfig>('app-config', default)`.
2.  **Drafts:**
    *   Create a `draftsAtom` (Map<CheckId, FormData>).
    *   `CheckFormView` initializes from `draftsAtom`.
3.  **Search:**
    *   Create `debouncedSearchQueryAtom` that updates 300ms after the raw input atom.
    *   Point filters to the debounced atom.

### 6. File Manifest
*   `src/data/atoms.ts` [MODIFIED]
*   `src/data/appDataAtoms.ts` [MODIFIED]
*   `src/features/Workflow/CheckFormView.tsx` [MODIFIED]

### 7. Unintended Consequences Check
*   **Schema Evolution:** If we change the `AppConfig` shape, `localStorage` might crash the app on load.
*   **Mitigation:** Add a version check or try/catch block in the storage initialization to wipe old data if schema mismatches.

### 8. Risks & Mitigations
*   **Risk:** Stale drafts showing up for a resident whose status has changed.
*   **Mitigation:** Clear draft on successful submission.

### 9. Definition of Done
*   [ ] Reloading the page preserves "List View" preference.
*   [ ] Typing in search doesn't lag (debounced).
*   [ ] Clicking "Back" then returning to the form restores typed notes.